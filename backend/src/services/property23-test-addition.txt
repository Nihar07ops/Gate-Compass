
    // Feature: gate-compass, Property 23: Navigation state preservation
    // **Validates: Requirements 6.2, 6.5**
    // For any question in an active test session, if a user enters an answer, navigates away, and then returns to that question, the previously entered answer should still be present.

    describe('Property 23: Navigation state preservation', () => {
        let service: TestSessionService;
        const mockPool = pool as any;
        const mockRedis = redisClient as any;

        beforeEach(() => {
            service = new TestSessionService();
            jest.clearAllMocks();
        });

        // Generator for valid session IDs
        const sessionIdArb = fc.uuid();

        // Generator for valid user IDs
        const userIdArb = fc.uuid();

        // Generator for valid test IDs
        const testIdArb = fc.uuid();

        // Generator for valid question IDs
        const questionIdArb = fc.uuid();

        // Generator for answer choices (A, B, C, D)
        const answerArb = fc.constantFrom('A', 'B', 'C', 'D');

        // Generator for review flag
        const reviewFlagArb = fc.boolean();

        // Generator for active test sessions
        const activeSessionArb = fc
            .tuple(sessionIdArb, userIdArb, testIdArb)
            .map(([sessionId, userId, testId]) => ({
                id: sessionId,
                user_id: userId,
                test_id: testId,
                start_time: new Date(Date.now() - 60000), // Started 1 minute ago
                end_time: null,
                status: 'in_progress' as const,
                total_time_spent: 0,
                created_at: new Date(Date.now() - 120000),
            }));

        it('should preserve answer when navigating away and returning to a question', async () => {
            await fc.assert(
                fc.asyncProperty(
                    activeSessionArb,
                    questionIdArb,
                    answerArb,
                    reviewFlagArb,
                    async (sessionRow, questionId, selectedAnswer, markedForReview) => {
                        // Step 1: Save an answer for a question
                        // Mock session active check
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock check for existing answer (none exists)
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock insert answer
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis operations for updateAnswerInRedis
                        mockRedis.get.mockResolvedValueOnce(null);

                        // Mock getSessionStateFromDatabase
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock answers query (empty initially)
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock times query
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis setEx
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        // Save the answer
                        await service.saveAnswer(sessionRow.id, {
                            questionId,
                            selectedAnswer,
                            markedForReview,
                        });

                        // Step 2: Simulate navigation away (no action needed)
                        // Clear mocks to simulate fresh retrieval
                        jest.clearAllMocks();

                        // Step 3: Return to the question and retrieve session state
                        // Mock Redis get (cache miss)
                        mockRedis.get.mockResolvedValueOnce(null);

                        // Mock getSessionStateFromDatabase
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock answers query - return the saved answer
                        mockPool.query.mockResolvedValueOnce({
                            rows: [{
                                session_id: sessionRow.id,
                                question_id: questionId,
                                selected_answer: selectedAnswer,
                                marked_for_review: markedForReview,
                                answered_at: new Date(),
                            }],
                        } as any);

                        // Mock times query
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis setEx
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        // Retrieve session state
                        const state = await service.getSessionState(sessionRow.id);

                        // Property: The previously entered answer should still be present
                        expect(state).not.toBeNull();
                        expect(state!.answers[questionId]).toBeDefined();
                        expect(state!.answers[questionId].selectedAnswer).toBe(selectedAnswer);
                        expect(state!.answers[questionId].markedForReview).toBe(markedForReview);
                    }
                ),
                { numRuns: 100 }
            );
        });

        it('should preserve multiple answers across navigation', async () => {
            await fc.assert(
                fc.asyncProperty(
                    activeSessionArb,
                    fc.array(fc.tuple(questionIdArb, answerArb, reviewFlagArb), { minLength: 2, maxLength: 5 }),
                    async (sessionRow, questionAnswerPairs) => {
                        // Ensure questions are unique
                        const uniqueQuestions = new Map<string, { answer: string; review: boolean }>();
                        questionAnswerPairs.forEach(([qId, answer, review]) => {
                            if (!uniqueQuestions.has(qId)) {
                                uniqueQuestions.set(qId, { answer, review });
                            }
                        });

                        fc.pre(uniqueQuestions.size >= 2); // Need at least 2 different questions

                        // Save answers for all questions
                        for (const [questionId, { answer, review }] of uniqueQuestions.entries()) {
                            // Mock session active check
                            mockPool.query.mockResolvedValueOnce({
                                rows: [sessionRow],
                            } as any);

                            // Mock check for existing answer
                            mockPool.query.mockResolvedValueOnce({
                                rows: [],
                            } as any);

                            // Mock insert answer
                            mockPool.query.mockResolvedValueOnce({
                                rows: [],
                            } as any);

                            // Mock Redis operations
                            mockRedis.get.mockResolvedValueOnce(null);
                            mockPool.query.mockResolvedValueOnce({ rows: [sessionRow] } as any);
                            mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                            mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                            mockRedis.setEx.mockResolvedValueOnce('OK');

                            await service.saveAnswer(sessionRow.id, {
                                questionId,
                                selectedAnswer: answer,
                                markedForReview: review,
                            });
                        }

                        // Clear mocks and retrieve session state
                        jest.clearAllMocks();

                        // Mock Redis get (cache miss)
                        mockRedis.get.mockResolvedValueOnce(null);

                        // Mock getSessionStateFromDatabase
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock answers query - return all saved answers
                        const savedAnswers = Array.from(uniqueQuestions.entries()).map(([qId, { answer, review }]) => ({
                            session_id: sessionRow.id,
                            question_id: qId,
                            selected_answer: answer,
                            marked_for_review: review,
                            answered_at: new Date(),
                        }));

                        mockPool.query.mockResolvedValueOnce({
                            rows: savedAnswers,
                        } as any);

                        // Mock times query
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis setEx
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        // Retrieve session state
                        const state = await service.getSessionState(sessionRow.id);

                        // Property: All previously entered answers should be preserved
                        expect(state).not.toBeNull();
                        expect(Object.keys(state!.answers).length).toBe(uniqueQuestions.size);

                        uniqueQuestions.forEach(({ answer, review }, questionId) => {
                            expect(state!.answers[questionId]).toBeDefined();
                            expect(state!.answers[questionId].selectedAnswer).toBe(answer);
                            expect(state!.answers[questionId].markedForReview).toBe(review);
                        });
                    }
                ),
                { numRuns: 100 }
            );
        });

        it('should preserve updated answer when changing answer and navigating', async () => {
            await fc.assert(
                fc.asyncProperty(
                    activeSessionArb,
                    questionIdArb,
                    answerArb,
                    answerArb,
                    reviewFlagArb,
                    async (sessionRow, questionId, firstAnswer, secondAnswer, markedForReview) => {
                        // Ensure answers are different
                        fc.pre(firstAnswer !== secondAnswer);

                        // Step 1: Save initial answer
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis operations
                        mockRedis.get.mockResolvedValueOnce(null);
                        mockPool.query.mockResolvedValueOnce({ rows: [sessionRow] } as any);
                        mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                        mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        await service.saveAnswer(sessionRow.id, {
                            questionId,
                            selectedAnswer: firstAnswer,
                            markedForReview: false,
                        });

                        // Step 2: Update answer
                        jest.clearAllMocks();

                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock existing answer found
                        mockPool.query.mockResolvedValueOnce({
                            rows: [{
                                session_id: sessionRow.id,
                                question_id: questionId,
                                selected_answer: firstAnswer,
                                marked_for_review: false,
                                answered_at: new Date(),
                            }],
                        } as any);

                        // Mock update query
                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis operations
                        mockRedis.get.mockResolvedValueOnce(null);
                        mockPool.query.mockResolvedValueOnce({ rows: [sessionRow] } as any);
                        mockPool.query.mockResolvedValueOnce({
                            rows: [{
                                session_id: sessionRow.id,
                                question_id: questionId,
                                selected_answer: firstAnswer,
                                marked_for_review: false,
                                answered_at: new Date(),
                            }],
                        } as any);
                        mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        await service.saveAnswer(sessionRow.id, {
                            questionId,
                            selectedAnswer: secondAnswer,
                            markedForReview,
                        });

                        // Step 3: Navigate away and return
                        jest.clearAllMocks();

                        mockRedis.get.mockResolvedValueOnce(null);
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        // Mock answers query - return updated answer
                        mockPool.query.mockResolvedValueOnce({
                            rows: [{
                                session_id: sessionRow.id,
                                question_id: questionId,
                                selected_answer: secondAnswer,
                                marked_for_review: markedForReview,
                                answered_at: new Date(),
                            }],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        const state = await service.getSessionState(sessionRow.id);

                        // Property: The updated answer should be preserved, not the original
                        expect(state).not.toBeNull();
                        expect(state!.answers[questionId]).toBeDefined();
                        expect(state!.answers[questionId].selectedAnswer).toBe(secondAnswer);
                        expect(state!.answers[questionId].selectedAnswer).not.toBe(firstAnswer);
                        expect(state!.answers[questionId].markedForReview).toBe(markedForReview);
                    }
                ),
                { numRuns: 100 }
            );
        });

        it('should not preserve answers for questions that were never answered', async () => {
            await fc.assert(
                fc.asyncProperty(
                    activeSessionArb,
                    fc.array(questionIdArb, { minLength: 2, maxLength: 5 }),
                    answerArb,
                    reviewFlagArb,
                    async (sessionRow, questionIds, selectedAnswer, markedForReview) => {
                        // Ensure we have at least 2 unique questions
                        fc.pre(new Set(questionIds).size >= 2);

                        const answeredQuestionId = questionIds[0];
                        const unansweredQuestionId = questionIds[1];

                        // Save answer only for the first question
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        // Mock Redis operations
                        mockRedis.get.mockResolvedValueOnce(null);
                        mockPool.query.mockResolvedValueOnce({ rows: [sessionRow] } as any);
                        mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                        mockPool.query.mockResolvedValueOnce({ rows: [] } as any);
                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        await service.saveAnswer(sessionRow.id, {
                            questionId: answeredQuestionId,
                            selectedAnswer,
                            markedForReview,
                        });

                        // Navigate and retrieve session state
                        jest.clearAllMocks();

                        mockRedis.get.mockResolvedValueOnce(null);
                        mockPool.query.mockResolvedValueOnce({
                            rows: [sessionRow],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [{
                                session_id: sessionRow.id,
                                question_id: answeredQuestionId,
                                selected_answer: selectedAnswer,
                                marked_for_review: markedForReview,
                                answered_at: new Date(),
                            }],
                        } as any);

                        mockPool.query.mockResolvedValueOnce({
                            rows: [],
                        } as any);

                        mockRedis.setEx.mockResolvedValueOnce('OK');

                        const state = await service.getSessionState(sessionRow.id);

                        // Property: Only answered questions should have preserved state
                        expect(state).not.toBeNull();
                        expect(state!.answers[answeredQuestionId]).toBeDefined();
                        expect(state!.answers[unansweredQuestionId]).toBeUndefined();
                    }
                ),
                { numRuns: 100 }
            );
        });
    });
});